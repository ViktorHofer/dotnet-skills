<!-- AUTO-GENERATED — DO NOT EDIT. Regenerate with: node eng/compile-knowledge.js -->

---
name: common-build-errors
description: "Knowledge base of common .NET and MSBuild build errors with root causes and solutions. Use when encountering CS, MSB, NU, NETSDK, FS, or BC error codes during dotnet build, dotnet test, msbuild, or dotnet pack. Provides step-by-step fix guidance for each error. DO NOT use for non-.NET build errors (npm, Gradle, CMake, etc.)."
---

# Common .NET and MSBuild Build Errors

## CS Errors (C# Compiler)

### CS0246: The type or namespace name could not be found

**What it means:** The compiler cannot resolve a type or namespace used in code.

**Common root causes:**
- Missing `using` directive for the namespace containing the type
- Missing `<PackageReference>` in the project file for the NuGet package that provides the type
- Missing `<ProjectReference>` to a sibling project that defines the type
- The project targets a TFM where the type does not exist (e.g., using `HttpClient` without a reference on .NET Framework)
- Typo in the type or namespace name
- The package is restored but targets an incompatible framework — the type exists in the package but not for your TFM
- Conditional compilation (`#if`) excluding the code that defines the type

**Step-by-step fix:**
1. Verify spelling of the type name exactly matches the definition.
2. Add the correct `using` directive. Check the type's documentation for the full namespace.
3. If the type comes from a NuGet package, add `<PackageReference Include="PackageName" Version="X.Y.Z" />` to the `.csproj`.
4. If the type is in another project in the solution, add `<ProjectReference Include="..\OtherProject\OtherProject.csproj" />`.
5. Check the project's `<TargetFramework>` — some types only exist in specific TFMs. For example, `System.Text.Json` is inbox in `net6.0+` but requires a PackageReference on `netstandard2.0`.
6. Run `dotnet restore` after adding references.

**Prevention:**
- Use IDE auto-import features to add `using` directives.
- When adding new dependencies, always verify TFM compatibility on nuget.org.

---

### CS0103: The name does not exist in the current context

**What it means:** A variable, method, or type name is used but not declared in the accessible scope.

**Common root causes:**
- Typo in variable or method name
- Variable declared in a different scope (e.g., inside an `if` block, used outside it)
- Missing `using` directive for an extension method's namespace
- Missing `using static` for a static method call
- Code generated by a source generator that hasn't run yet (restore/build order issue)

**Step-by-step fix:**
1. Check spelling of the identifier against its declaration.
2. Verify the variable is declared in a scope visible at the usage site.
3. If calling a static method without the class prefix, add `using static Full.Namespace.ClassName;`.
4. If the name is expected to come from a source generator, ensure the generator package is referenced and `dotnet restore` has been run.
5. Check for `#if` preprocessor directives that might exclude the declaration.

**Prevention:**
- Declare variables at the narrowest scope needed but ensure it covers all usage sites.
- Use consistent naming to avoid typos.

---

### CS1061: Type does not contain a definition for member

**What it means:** You are calling a method or accessing a property that does not exist on the type.

**Common root causes:**
- The member name is misspelled
- The member exists in a different version of the API — package was upgraded or downgraded
- The member is an extension method and the namespace containing it is not imported via `using`
- The variable is a different type than expected (e.g., `object` instead of the concrete type)
- The member was removed or renamed in a newer version of the dependency

**Step-by-step fix:**
1. Verify the exact member name against the API documentation for the version you're using.
2. Check the type of the variable — hover or use `GetType()` at runtime. Cast if needed.
3. For extension methods, add the `using` for the namespace that defines them (e.g., `using System.Linq;` for LINQ methods).
4. Check the package version in your `.csproj` — the member may not exist in the version you have. Compare with API docs or release notes.
5. If the API changed, find the replacement method in the changelog or migration guide.

**Prevention:**
- Pin package versions explicitly.
- Review breaking changes before upgrading major versions.

---

### CS0234: The type or namespace name does not exist in the namespace

**What it means:** The namespace is found but the specific type or sub-namespace within it cannot be resolved.

**Common root causes:**
- The type was moved to a different namespace in a newer version of the library
- A required sub-package is missing (e.g., `Microsoft.Extensions.Logging` exists but `Microsoft.Extensions.Logging.Console` is a separate package)
- The type exists only in certain TFMs
- InternalsVisibleTo is needed but not configured

**Step-by-step fix:**
1. Search the NuGet package contents or documentation for the exact namespace that now contains the type.
2. Check if the type requires an additional package — many `Microsoft.Extensions.*` namespaces are split across multiple packages.
3. Verify TFM compatibility.
4. If accessing internal types, ensure `[InternalsVisibleTo]` is set on the defining assembly.

**Prevention:**
- Review migration guides when upgrading packages.

---

### CS0012: The type is defined in an assembly that is not referenced

**What it means:** Your code uses a type that comes from a transitive dependency, but the compiler requires a direct reference to that assembly.

**Common root causes:**
- A method returns or accepts a type from a dependency you don't directly reference
- Transitive dependency is not flowing through — `PrivateAssets="all"` on the intermediate reference
- Multi-targeting where the transitive reference exists for one TFM but not another

**Step-by-step fix:**
1. Identify the assembly that defines the type from the error message.
2. Add a direct `<PackageReference>` or `<ProjectReference>` to the assembly containing the type.
3. If this is a transitive reference that should flow, check the intermediate project for `PrivateAssets` or `ExcludeAssets` settings that prevent it.

**Prevention:**
- When exposing types from dependencies in your public API, document the required direct references.

---

### CS8032: An instance of analyzer could not be created

**What it means:** The Roslyn analyzer or source generator failed to load.

**Common root causes:**
- Analyzer package version is incompatible with the current Roslyn/SDK version
- Analyzer targets a newer .NET runtime than the one used by the build
- The analyzer package is corrupt or partially restored
- Multiple conflicting versions of the same analyzer are loaded

**Step-by-step fix:**
1. Check the analyzer package version. Upgrade to the latest version compatible with your SDK.
2. Run `dotnet nuget locals all --clear` and `dotnet restore` to get a clean restore.
3. Check `dotnet --version` — some analyzers require a minimum SDK version.
4. Look for duplicate analyzer references in `Directory.Build.props`, `.csproj`, and transitive dependencies.
5. If the analyzer is optional, suppress with `<NoWarn>CS8032</NoWarn>` temporarily while investigating.

**Prevention:**
- Keep analyzer packages updated when upgrading the SDK.
- Test analyzer compatibility in CI before upgrading.

---

### CS0618: Member is obsolete / CS0619: Member is obsolete and errors

**What it means:** You are using an API member marked with `[Obsolete]`. CS0618 is a warning; CS0619 is an error (when `[Obsolete("...", true)]` is used).

**Common root causes:**
- API was deprecated in a newer version of the library
- The project upgraded a dependency and the previously-used API is now obsolete

**Step-by-step fix:**
1. Read the obsolete message in the warning/error — it typically names the replacement API.
2. If no replacement is named, check the library's migration guide, changelog, or API docs.
3. Replace the obsolete call with the recommended alternative.
4. For CS0618 (warning), if you must temporarily keep the old call, suppress with `#pragma warning disable CS0618` around the call, with a comment explaining when to remove.
5. CS0619 (error) cannot be suppressed — you must replace the call.

**Prevention:**
- Treat warnings as errors (`<TreatWarningsAsErrors>true</TreatWarningsAsErrors>`) to catch deprecations early.

---

### CS0535: Does not implement interface member

**What it means:** A class declares it implements an interface but is missing one or more required members.

**Common root causes:**
- New members were added to the interface in an updated dependency
- The method signature does not exactly match (wrong return type, parameter types, or name)
- Explicit interface implementation is used but the method is missing
- The interface has default implementations but you're targeting a TFM that doesn't support them (pre-C# 8 / pre-netstandard2.1)

**Step-by-step fix:**
1. Check the full interface definition for the version of the dependency you're using.
2. Implement each missing member with the exact signature.
3. If the interface gained new members after an upgrade, check the release notes for guidance on the expected implementation.
4. Use IDE "Implement Interface" refactoring to scaffold missing members.

**Prevention:**
- Review interface changes in release notes before upgrading dependencies.

---

### CS0029: Cannot implicitly convert type

**What it means:** The compiler cannot automatically convert between two types.

**Common root causes:**
- Assigning a value of one type to a variable of an incompatible type
- Nullable reference type (`string?`) assigned to non-nullable (`string`) without null check
- `Task<T>` assigned where `T` is expected (missing `await`)
- Integer types of different widths (e.g., `long` to `int`)
- Custom types that look similar but are from different assemblies or namespaces

**Step-by-step fix:**
1. Check both the source type and target type in the error message.
2. If the types are compatible, add an explicit cast: `(TargetType)value`.
3. If the source is `Task<T>`, add `await` to the expression.
4. If the types are from different assemblies with the same name, fix the reference to use only one.
5. For nullable-to-non-nullable, add a null check or use the `!` operator if you're certain the value is not null.

**Prevention:**
- Enable nullable reference types (`<Nullable>enable</Nullable>`) to catch null issues at compile time.
- Use `await` consistently with async methods.

---

### CS8600–CS8605: Nullable Reference Type Warnings/Errors

**What they mean:**
- **CS8600**: Converting null literal or possible null value to non-nullable type
- **CS8601**: Possible null reference assignment
- **CS8602**: Dereference of a possibly null reference
- **CS8603**: Possible null reference return
- **CS8604**: Possible null reference argument
- **CS8605**: Unboxing a possibly null value

**Common root causes:**
- Nullable reference types are enabled (`<Nullable>enable</Nullable>`) and the code doesn't handle null properly
- A method returns `T?` but the caller treats it as `T`
- API contracts changed — a previously non-nullable return is now nullable
- Third-party library lacks nullable annotations

**Step-by-step fix:**
1. **Preferred:** Add proper null checks before using the value:
   ```csharp
   if (value is not null) { /* use value */ }
   ```
2. Use null-conditional operators: `value?.Method()`.
3. Use the null-forgiving operator `!` only when you are certain the value is not null and the analyzer can't prove it.
4. Annotate your own method signatures correctly with `?` for nullable parameters/returns.
5. To suppress project-wide (not recommended), set `<Nullable>disable</Nullable>` or `<Nullable>warnings</Nullable>`.
6. For third-party APIs without annotations, use `!` at the call site sparingly.

**Prevention:**
- Enable nullable reference types from the start of a project.
- Use `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` to enforce handling.

---

## MSB Errors (MSBuild Engine)

### MSB4019: The imported project was not found

**What it means:** An MSBuild `<Import>` statement references a `.props` or `.targets` file that does not exist on disk.

**Common root causes:**
- Required SDK or workload is not installed (e.g., `Microsoft.NET.Sdk.Web`)
- The `MSBUILD_SDKS_PATH` or SDK resolver path is misconfigured
- A custom `.props`/`.targets` file referenced via a relative path doesn't exist
- The NuGet package that provides the import was not restored
- Corrupt SDK installation
- `global.json` pins an SDK version that is not installed

**Step-by-step fix:**
1. Read the full path in the error message to identify which file is missing.
2. If it's an SDK import (e.g., `Microsoft.NET.Sdk`), run `dotnet --list-sdks` and install the required SDK.
3. If `global.json` exists, check if the pinned SDK version is installed.
4. If the import comes from a NuGet package, run `dotnet restore`.
5. If the import path is custom, verify the file exists at the expected relative path.
6. As a last resort, repair or reinstall the .NET SDK.

**Prevention:**
- Use `global.json` with a `rollForward` policy to avoid pinning to an exact patch version.
- In CI, install the exact SDK version required before building.

---

### MSB3644: The reference assemblies for framework were not found

**What it means:** The targeting pack for the specified TFM is not installed.

**Common root causes:**
- Targeting a .NET Framework version (e.g., `net472`) without the corresponding targeting pack installed
- The .NET Framework Developer Pack is not installed on the build machine
- Multi-targeting includes a TFM for which no targeting pack exists
- Running on Linux/macOS where .NET Framework targeting packs are unavailable without `Microsoft.NETFramework.ReferenceAssemblies` package

**Step-by-step fix:**
1. Install the appropriate .NET Framework Developer Pack from Microsoft.
2. For cross-platform builds targeting .NET Framework, add:
   ```xml
   <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="all" />
   ```
3. If you don't need that TFM, remove it from `<TargetFrameworks>`.

**Prevention:**
- Always include `Microsoft.NETFramework.ReferenceAssemblies` when multi-targeting with .NET Framework TFMs.

---

### MSB3270: There was a mismatch between the processor architecture

**What it means:** A referenced assembly's processor architecture conflicts with the project's target platform.

**Common root causes:**
- Referencing an x86-only assembly from an AnyCPU or x64 project
- Native interop DLLs built for wrong architecture
- Platform target set explicitly in one project but not its dependencies

**Step-by-step fix:**
1. Check `<PlatformTarget>` in both the referencing and referenced projects.
2. Set all projects to `AnyCPU` unless a specific platform is required.
3. If a native dependency requires a specific platform, set all projects in the dependency chain to the same platform, or use `<ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>` to suppress if the mismatch is safe.
4. For native DLLs, provide both x86 and x64 versions and use runtime architecture selection.

**Prevention:**
- Use `AnyCPU` unless you have a specific reason for a platform-specific build.

---

### MSB4181: The task returned false but did not log an error

**What it means:** A custom MSBuild task's `Execute()` method returned `false` (indicating failure) but didn't call `Log.LogError()`.

**Common root causes:**
- Bug in a custom MSBuild task
- The task caught an exception and returned false without logging
- A third-party task has a bug
- Task is swallowing errors internally

**Step-by-step fix:**
1. Identify the task name from the error message.
2. If it's a custom task, fix the `Execute()` method to call `Log.LogError()` before returning `false`.
3. If it's a third-party task, check for updates or file a bug.
4. Build with `dotnet build /bl` and inspect the binlog for more context on what the task was doing.

**Prevention:**
- In custom tasks, always log an error before returning `false`.

---

### MSB3277: Found conflicts between different versions of the same assembly

**What it means:** Multiple dependencies reference different versions of the same assembly, and MSBuild cannot resolve the conflict.

**Common root causes:**
- Transitive dependencies pulling in different versions of a shared library
- Mixing package versions across projects in a solution
- Explicit assembly references (`<Reference>`) conflicting with NuGet-managed versions (note: `<Reference>` is still valid for .NET Framework GAC assemblies like `WindowsBase`)

**Step-by-step fix:**
1. Build with `/bl` and inspect the binlog to see exactly which assemblies conflict.
2. Use `<PackageReference Update="ConflictingPackage" Version="X.Y.Z" />` in `Directory.Build.props` to unify the version across the solution.
3. If using binding redirects (.NET Framework), add or update them in `app.config`.
4. Run `dotnet list package --include-transitive` to see the full dependency graph.
5. Consider using `<CentralPackageManagement>` to enforce consistent versions.

**Prevention:**
- Use Central Package Management (`Directory.Packages.props`) to pin all package versions in one place.

---

### MSB3247: Items had more than one distinct identity within the same ItemGroup

**What it means:** The same item (usually a file) appears more than once in an ItemGroup with conflicting metadata.

**Common root causes:**
- Duplicate `<Compile>`, `<Content>`, or `<None>` entries in the `.csproj`
- Default glob patterns (implicit includes) conflict with explicit includes
- `Directory.Build.props` adds items that the project also adds

**Step-by-step fix:**
1. Check for explicit `<Compile Include="...">` entries that overlap with the default glob (`**/*.cs`).
2. Remove explicit includes that duplicate what the SDK already includes by default.
3. If you need custom metadata on a specific file, use `<Compile Update="file.cs">` instead of `<Compile Include="file.cs">`.
4. Check `Directory.Build.props` and `Directory.Build.targets` for conflicting item additions.

**Prevention:**
- Use `Update` instead of `Include` for files already covered by SDK default globs.
- Avoid mixing SDK-style and non-SDK-style item patterns.

---

### MSB1009: Project file does not exist

**What it means:** MSBuild cannot find the specified project file at the given path.

**Common root causes:**
- Typo in the project file path passed to `dotnet build`
- Case-sensitive file system (Linux) and the casing doesn't match
- The `.csproj` was deleted, moved, or renamed
- Solution file references a project that no longer exists

**Step-by-step fix:**
1. Verify the project file exists at the exact path shown in the error.
2. On Linux, check case sensitivity — `MyProject.csproj` vs `myproject.csproj`.
3. If building a solution, open the `.sln` file and remove or fix stale project references.
4. Check that the working directory is correct.

**Prevention:**
- Use `dotnet sln list` to verify solution contents.
- Use relative paths in solution files.

---

### MSB4236: The SDK could not be found

**What it means:** The MSBuild SDK specified in the project file cannot be resolved.

**Common root causes:**
- Required SDK is not installed (e.g., `Microsoft.NET.Sdk.Worker`, `Microsoft.NET.Sdk.BlazorWebAssembly`)
- `global.json` specifies an SDK version that's not installed
- Custom SDK resolver is misconfigured
- Workload-provided SDKs require the workload to be installed first

**Step-by-step fix:**
1. Check the SDK name in the `<Project Sdk="...">` attribute.
2. Run `dotnet --list-sdks` to see installed SDKs.
3. If `global.json` exists, verify the pinned version is installed or adjust the `rollForward` policy.
4. For workload SDKs (Blazor, MAUI, etc.), run `dotnet workload install <workload>`.
5. Install the required SDK from https://dot.net.

**Prevention:**
- Document required SDK versions and workloads in the repo's README or a setup script.

---

### MSB3106: Assembly name conflict

**What it means:** Two or more projects in the solution produce an output assembly with the same name.

**Common root causes:**
- Copy-pasted project files that retained the same `<AssemblyName>`
- Default assembly name (derived from project file name) collides when projects share the same name in different directories
- Test project and main project have the same assembly name

**Step-by-step fix:**
1. Set a unique `<AssemblyName>` in each conflicting project's `.csproj`.
2. If the projects are in different folders with the same name, rename one of them.
3. Check that `<RootNamespace>` is also unique to avoid confusion.

**Prevention:**
- Use distinct project names across the solution.

---

## NU Errors (NuGet)

### NU1101: Unable to find package

**What it means:** NuGet cannot locate the specified package in any configured source.

**Common root causes:**
- Typo in the package name
- The package exists on a private feed that is not configured
- The package was delisted or removed
- `nuget.config` is missing or not pointing to the correct feed
- Network/firewall blocking access to nuget.org

**Step-by-step fix:**
1. Verify the exact package name on nuget.org or your private feed.
2. Run `dotnet nuget list source` to see configured sources.
3. Add missing sources: `dotnet nuget add source <URL> --name <name>`.
4. For private feeds, configure authentication in `nuget.config`:
   ```xml
   <packageSourceCredentials>
     <FeedName>
       <add key="Username" value="..." />
       <add key="ClearTextPassword" value="..." />
     </FeedName>
   </packageSourceCredentials>
   ```
5. Check network connectivity to the feed URL.

**Prevention:**
- Commit a `nuget.config` to the repo with all required sources.
- Use `dotnet nuget list source` to validate in CI setup steps.

---

### NU1202: Package is not compatible with target framework

**What it means:** The package exists but does not support your project's TFM.

**Common root causes:**
- Package only supports newer TFMs than your project targets
- Package only supports .NET Framework, not .NET (Core), or vice versa
- Using a pre-release version that dropped support for your TFM

**Step-by-step fix:**
1. Check the package's supported frameworks on nuget.org under "Frameworks".
2. Use a version of the package that supports your TFM.
3. If possible, upgrade your project's TFM to one the package supports.
4. Look for an alternative package that supports your TFM.

**Prevention:**
- Check TFM compatibility before adding a PackageReference.

---

### NU1605: Detected package downgrade

**What it means:** A dependency requires a higher version of a package than what is explicitly referenced.

**Common root causes:**
- Explicit `<PackageReference>` pins a lower version than a transitive dependency requires
- Multiple projects in the solution reference different versions

**Step-by-step fix:**
1. Upgrade the explicit PackageReference to at least the version required by the transitive dependency.
2. Run `dotnet list package --include-transitive` to see which dependency requires the higher version.
3. If downgrade is intentional, suppress with `<NoWarn>NU1605</NoWarn>` on the PackageReference (not recommended).

**Prevention:**
- Use Central Package Management to keep versions consistent.
- Regularly run `dotnet list package --outdated` to find version mismatches.

---

### NU1100: Unable to resolve dependencies

**What it means:** NuGet cannot find a set of package versions that satisfies all dependency constraints.

**Common root causes:**
- Two packages require incompatible versions of a shared dependency
- A package version does not exist for the required version range
- Private feed is missing a required transitive package

**Step-by-step fix:**
1. Read the full error output — it shows the conflicting dependency chains.
2. Try upgrading or downgrading one of the conflicting top-level packages.
3. Check if a newer version of either package resolves the conflict.
4. Use `dotnet list package --include-transitive` to map the dependency graph.
5. As a last resort, add a direct PackageReference to the conflicting transitive package at a version that satisfies both constraints.

**Prevention:**
- Keep packages up to date to minimize version range conflicts.

---

### NU1301: Unable to load the service index for source

**What it means:** NuGet cannot connect to a package source to query available packages.

**Common root causes:**
- Network connectivity issue or firewall blocking the feed URL
- Private feed requires authentication that is not configured
- Feed URL is incorrect or the feed is down
- Expired or invalid authentication token (PAT, API key)
- Corporate proxy not configured

**Step-by-step fix:**
1. Test the feed URL in a browser or with `curl`.
2. Check `nuget.config` for the correct feed URL.
3. For private feeds, update credentials. For Azure DevOps, use `dotnet nuget update source <name> --username <user> --password <PAT>`.
4. If behind a proxy, configure proxy settings in `nuget.config`.
5. If the feed is temporarily down, retry later or configure a fallback source.

**Prevention:**
- Use credential providers for automatic token refresh.
- Configure fallback sources for resilience.

---

### NU1701: Package was restored using a different target framework fallback

**What it means:** NuGet used a compatibility shim to restore a package that doesn't directly support your TFM. It may work but is not guaranteed.

**Common root causes:**
- Package only targets `netstandard1.x` or `net4x` but you're on `net6.0+`
- Old package that hasn't been updated for newer TFMs

**Step-by-step fix:**
1. Check if a newer version of the package supports your TFM natively.
2. If the package works correctly despite the warning, suppress with `<NoWarn>NU1701</NoWarn>` on the specific PackageReference.
3. Consider finding an alternative package with better TFM support.

**Prevention:**
- Prefer packages that target `netstandard2.0` or your specific TFM.

---

### NU1603: Dependency version does not exist

**What it means:** A package declares a dependency on a specific version of another package, but that version does not exist in any configured source.

**Common root causes:**
- The dependency version was unlisted or deleted from the feed
- Private feed is missing the required version
- Package metadata is incorrect

**Step-by-step fix:**
1. Check the feed for available versions of the missing dependency.
2. Try a newer version of the top-level package that depends on an available version.
3. Add a direct PackageReference to an available version of the missing dependency.

**Prevention:**
- Use feeds that mirror/cache packages to avoid issues with removed versions.

---

### NU1108: Circular dependency detected

**What it means:** Two or more packages depend on each other, creating a circular reference.

**Common root causes:**
- ProjectReferences form a cycle (A → B → A)
- Package A depends on Package B which depends on Package A (rare for public packages, common for in-house packages)

**Step-by-step fix:**
1. Map out the dependency chain from the error message.
2. Break the cycle by extracting shared types into a new project/package that both can reference.
3. Use interfaces or abstractions to decouple the dependencies.
4. If the cycle is in ProjectReferences, restructure the solution to eliminate the circular path.

**Prevention:**
- Design packages with a clear dependency hierarchy — no cycles.
- Use architecture tools to enforce layering rules.

---

## NETSDK Errors (.NET SDK)

### NETSDK1004: Assets file not found

**What it means:** The `project.assets.json` file (generated by `dotnet restore`) is missing.

**Common root causes:**
- `dotnet restore` was not run before building
- The `obj/` folder was deleted without re-restoring
- Restore failed silently
- CI pipeline skips the restore step

**Step-by-step fix:**
1. Run `dotnet restore` explicitly.
2. If restore was already run, delete the `obj/` folder and restore again.
3. Check for restore errors in the output — a failed restore won't produce the assets file.
4. Ensure `nuget.config` is correctly configured.

**Prevention:**
- Always run `dotnet restore` before `dotnet build` in CI.
- Use `dotnet build` which implicitly restores unless `--no-restore` is passed.

---

### NETSDK1005: Assets file has a target for a different framework

**What it means:** The `project.assets.json` was generated for a different TFM than the project is currently targeting.

**Common root causes:**
- `<TargetFramework>` was changed in the `.csproj` without re-restoring
- Stale `obj/` folder from a previous configuration

**Step-by-step fix:**
1. Run `dotnet restore` to regenerate the assets file for the current TFM.
2. If the issue persists, delete the `obj/` folder and restore again.

**Prevention:**
- Always restore after changing `<TargetFramework>`.

---

### NETSDK1045: The current .NET SDK does not support targeting the specified framework

**What it means:** The installed SDK version is too old to build for the specified TFM.

**Common root causes:**
- Project targets `net8.0` but only .NET 7 SDK is installed
- `global.json` pins an older SDK version
- CI image has an outdated SDK

**Step-by-step fix:**
1. Run `dotnet --list-sdks` to see installed versions.
2. Install the SDK version that supports the target framework (e.g., .NET 8 SDK for `net8.0`).
3. If `global.json` exists, update the SDK version or adjust `rollForward`.
4. In CI, update the SDK installation step.

**Prevention:**
- Use `global.json` with `"rollForward": "latestMajor"` or `"latestFeature"` for flexibility.
- Keep CI images updated.

---

### NETSDK1047: Assets file missing target for specified framework

**What it means:** The assets file exists but does not contain entries for the TFM being built. Similar to NETSDK1005.

**Common root causes:**
- Multi-targeted project where restore ran for a subset of TFMs
- TFM was added to `<TargetFrameworks>` without re-restoring
- Stale `obj/` folder

**Step-by-step fix:**
1. Run `dotnet restore` to regenerate assets for all TFMs.
2. Delete `obj/` and restore again if the issue persists.

**Prevention:**
- Restore after any change to `<TargetFrameworks>`.

---

### NETSDK1064: Package not compatible with target framework

**What it means:** A referenced package does not support the project's TFM and has no compatible fallback.

**Common root causes:**
- Package only supports older or different TFMs
- Multi-targeting includes a TFM the package doesn't support

**Step-by-step fix:**
1. Check the package's supported TFMs on nuget.org.
2. Use a version of the package that supports your TFM.
3. If multi-targeting, conditionally include the package only for supported TFMs:
   ```xml
   <PackageReference Include="SomePackage" Version="1.0.0" Condition="'$(TargetFramework)' == 'net6.0'" />
   ```
4. Find an alternative package.

**Prevention:**
- Check TFM support before adding dependencies.

---

### NETSDK1141: Unable to resolve the .NET SDK version as specified in global.json

**What it means:** The SDK version specified in `global.json` cannot be found, and the `rollForward` policy doesn't match any installed SDK.

**Common root causes:**
- `global.json` specifies an exact version that isn't installed
- `rollForward` is set to `"disable"` preventing any fallback
- CI machine doesn't have the required SDK

**Step-by-step fix:**
1. Check `global.json` for the specified version and `rollForward` policy.
2. Install the exact SDK version specified, or update `global.json`.
3. Set a more flexible `rollForward` policy:
   - `"latestPatch"` — allows patch-level upgrades (default)
   - `"latestFeature"` — allows feature band upgrades
   - `"latestMajor"` — allows any installed SDK
4. Delete `global.json` if it's not needed.

**Prevention:**
- Use `"rollForward": "latestFeature"` or `"latestPatch"` for flexibility.

---

### NETSDK1013: The TargetFramework value is not recognized

**What it means:** The TFM string in `<TargetFramework>` is malformed or unsupported.

**Common root causes:**
- Typo in the TFM (e.g., `net60` instead of `net6.0`, `netstandard2.1.0` instead of `netstandard2.1`)
- Using a TFM that requires a newer SDK than installed
- Mixing old and new TFM formats (e.g., `netcoreapp3.1` vs `net3.1`)

**Step-by-step fix:**
1. Verify the TFM matches an official value: `net6.0`, `net7.0`, `net8.0`, `netstandard2.0`, `net472`, etc.
2. Check https://learn.microsoft.com/dotnet/standard/frameworks for valid TFM strings.
3. Ensure the SDK installed supports the TFM. For example, `net9.0` requires .NET 9 SDK.

**Prevention:**
- Copy TFM strings from official documentation, not from memory.

---

### NETSDK1073: The FrameworkReference was not recognized

**What it means:** A `<FrameworkReference>` in the project refers to a framework that is not available.

**Common root causes:**
- Required workload is not installed (e.g., `Microsoft.AspNetCore.App` needs the ASP.NET workload)
- TFM does not support the framework reference
- Typo in the FrameworkReference name

**Step-by-step fix:**
1. Check the FrameworkReference name in the error.
2. Install the required workload: `dotnet workload install <workload>`.
3. Verify the framework reference is available for your TFM.
4. For ASP.NET references on non-web projects, use the correct SDK (`Microsoft.NET.Sdk.Web`) or add the FrameworkReference explicitly.

**Prevention:**
- Document required workloads in the repository.

---

### NETSDK1082: There was no runtime pack available for the specified platform

**What it means:** No runtime pack is available for the target runtime identifier (RID) in a self-contained deployment.

**Common root causes:**
- Invalid or unsupported RuntimeIdentifier (e.g., `linux-x64` typo)
- The runtime pack for the RID is not available in the configured feeds
- The TFM + RID combination is not supported

**Step-by-step fix:**
1. Check the `<RuntimeIdentifier>` in the project file for typos.
2. Verify the RID is valid: https://learn.microsoft.com/dotnet/core/rid-catalog.
3. Ensure the NuGet feeds contain runtime packs (nuget.org has them by default).
4. For framework-dependent deployment, remove `<SelfContained>true</SelfContained>` if self-contained is not needed.

**Prevention:**
- Use standard RIDs from the official catalog.

---

## Cross-Cutting Troubleshooting Guidance

When you encounter a build error and the specific fix above doesn't resolve it, follow these general troubleshooting steps in order:

### 1. Clean and Rebuild
```shell
dotnet clean
dotnet build
```
Removes cached build outputs that may be stale or corrupt.

### 2. Delete obj/ and bin/ Folders
```shell
# PowerShell
Get-ChildItem -Directory -Recurse -Include bin,obj | Remove-Item -Recurse -Force
dotnet restore
dotnet build
```
Eliminates all cached build state, assets files, and intermediate outputs. This is more thorough than `dotnet clean`.

### 3. Clear NuGet Cache
```shell
dotnet nuget locals all --clear
dotnet restore
```
Removes all cached NuGet packages. Resolves issues with corrupt or stale package downloads.

### 4. Check SDK Version
```shell
dotnet --list-sdks
dotnet --version
```
Verify the correct SDK is installed and active. Compare against `global.json` if present.

### 5. Check global.json
Look for `global.json` in the repo root or parent directories. It may pin the SDK version or roll-forward policy:
```json
{
  "sdk": {
    "version": "8.0.100",
    "rollForward": "latestFeature"
  }
}
```
If the pinned version isn't installed and `rollForward` is restrictive, the build will fail.

### 6. Verify NuGet Sources
```shell
dotnet nuget list source
```
Ensure all required feeds (nuget.org, private feeds) are configured and reachable. Check `nuget.config` for correct URLs and credentials.

### 7. Use Binary Logs for Deep Analysis
```shell
dotnet build /bl
```
This produces `msbuild.binlog` — a comprehensive record of the entire build. Use the MSBuild Structured Log Viewer or binlog analysis tools to:
- See the exact order of target and task execution
- Inspect property and item values at each point in the build
- Find the root cause of errors that produce unhelpful messages
- Trace dependency resolution and assembly conflict details

Binary logs are the single most effective diagnostic tool for complex build issues.

### 8. Check for Directory.Build.props / Directory.Build.targets
These files are automatically imported by MSBuild from the project directory and all parent directories up to the repo root. Unexpected build behavior is often caused by:
- Properties or items set in a `Directory.Build.props` you didn't know existed
- Multiple `Directory.Build.props` files in the directory hierarchy (only the nearest one is auto-imported — parent ones require explicit import)

Search for them:
```shell
# PowerShell — find all Directory.Build.* files
Get-ChildItem -Recurse -Filter "Directory.Build.*"
```

### 9. Restore-Build-Test Sequence
Always follow this order, especially in CI:
```shell
dotnet restore
dotnet build --no-restore
dotnet test --no-build
```
Using `--no-restore` and `--no-build` ensures each step uses the exact output of the previous step, avoiding hidden implicit restores or rebuilds.

---

## sourcegen-analyzer-failures

---
name: sourcegen-analyzer-failures
description: "Diagnose and fix source generator and Roslyn analyzer failures in .NET builds. Use when builds fail with CS8785 (source generator errors), AD0001 (analyzer exceptions), RS-prefixed errors, or when source generators produce no output. Covers generator crashes, analyzer exceptions, debugging with /p:ReportAnalyzer=true and binlog analysis, version mismatches, and TFM incompatibilities. DO NOT use for build errors unrelated to analyzers/generators (use common-build-errors instead)."
---

# Source Generator & Analyzer Failure Diagnosis

## Overview

Source generators and Roslyn analyzers run during compilation inside the Csc task. When they fail, the errors can be cryptic. This skill covers diagnosing and fixing these failures.

**Related skills:**
- `common-build-errors` — for general CS/MSB errors not related to generators/analyzers
- `analyzer-performance` — for slow (but working) analyzers, not crashes
- `binlog-failure-analysis` — for deep binlog analysis techniques

---

## Source Generator Failures

### CS8785: Generator 'X' failed to generate source

**What it means**: A source generator threw an unhandled exception during execution.

**Diagnosis steps:**

1. **Check the build output** for the full exception stack trace. MSBuild typically prints the inner exception after the CS8785 message.

2. **Generate a binlog** for deeper analysis:
   ```
   dotnet build /bl:generator-debug.binlog
   ```
   In the binlog, search fo

[truncated]