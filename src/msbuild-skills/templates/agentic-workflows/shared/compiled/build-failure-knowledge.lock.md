<!-- AUTO-GENERATED — DO NOT EDIT. Regenerate with: node eng/compile-knowledge.js -->

---
name: common-build-errors
description: "Knowledge base of common .NET and MSBuild build errors with root causes and solutions. Only activate in MSBuild/.NET build contexts (see shared/domain-check.md for signals). Use when encountering CS, MSB, NU, NETSDK, FS, or BC error codes during dotnet build, dotnet test, msbuild, or dotnet pack. Provides step-by-step fix guidance for each error. DO NOT use for non-.NET build errors (npm, Gradle, CMake, etc.)."
---

# Common .NET and MSBuild Build Errors

## CS Errors (C# Compiler)

### CS0246: The type or namespace name could not be found

**What it means:** The compiler cannot resolve a type or namespace used in code.

**Common root causes:**
- Missing `using` directive for the namespace containing the type
- Missing `<PackageReference>` in the project file for the NuGet package that provides the type
- Missing `<ProjectReference>` to a sibling project that defines the type
- The project targets a TFM where the type does not exist (e.g., using `HttpClient` without a reference on .NET Framework)
- Typo in the type or namespace name
- The package is restored but targets an incompatible framework — the type exists in the package but not for your TFM
- Conditional compilation (`#if`) excluding the code that defines the type

**Step-by-step fix:**
1. Verify spelling of the type name exactly matches the definition.
2. Add the correct `using` directive. Check the type's documentation for the full namespace.
3. If the type comes from a NuGet package, add `<PackageReference Include="PackageName" Version="X.Y.Z" />` to the `.csproj`.
4. If the type is in another project in the solution, add `<ProjectReference Include="..\OtherProject\OtherProject.csproj" />`.
5. Check the project's `<TargetFramework>` — some types only exist in specific TFMs. For example, `System.Text.Json` is inbox in `net6.0+` but requires a PackageReference on `netstandard2.0`.
6. Run `dotnet restore` after adding references.

**Prevention:**
- Use IDE auto-import features to add `using` directives.
- When adding new dependencies, always verify TFM compatibility on nuget.org.

---

### CS0103: The name does not exist in the current context

**What it means:** A variable, method, or type name is used but not declared in the accessible scope.

**Common root causes:**
- Typo in variable or method name
- Variable declared in a different scope (e.g., inside an `if` block, used outside it)
- Missing `using` directive for an extension method's namespace
- Missing `using static` for a static method call
- Code generated by a source generator that hasn't run yet (restore/build order issue)

**Step-by-step fix:**
1. Check spelling of the identifier against its declaration.
2. Verify the variable is declared in a scope visible at the usage site.
3. If calling a static method without the class prefix, add `using static Full.Namespace.ClassName;`.
4. If the name is expected to come from a source generator, ensure the generator package is referenced and `dotnet restore` has been run.
5. Check for `#if` preprocessor directives that might exclude the declaration.

**Prevention:**
- Declare variables at the narrowest scope needed but ensure it covers all usage sites.
- Use consistent naming to avoid typos.

---

### CS1061: Type does not contain a definition for member

**What it means:** You are calling a method or accessing a property that does not exist on the type.

**Common root causes:**
- The member name is misspelled
- The member exists in a different version of the API — package was upgraded or downgraded
- The member is an extension method and the namespace containing it is not imported via `using`
- The variable is a different type than expected (e.g., `object` instead of the concrete type)
- The member was removed or renamed in a newer version of the dependency

**Step-by-step fix:**
1. Verify the exact member name against the API documentation for the version you're using.
2. Check the type of the variable — hover or use `GetType()` at runtime. Cast if needed.
3. For extension methods, add the `using` for the namespace that defines them (e.g., `using System.Linq;` for LINQ methods).
4. Check the package version in your `.csproj` — the member may not exist in the version you have. Compare with API docs or release notes.
5. If the API changed, find the replacement method in the changelog or migration guide.

**Prevention:**
- Pin package versions explicitly.
- Review breaking changes before upgrading major versions.

---

### CS0234: The type or namespace name does not exist in the namespace

**What it means:** The namespace is found but the specific type or sub-namespace within it cannot be resolved.

**Common root causes:**
- The type was moved to a different namespace in a newer version of the library
- A required sub-package is missing (e.g., `Microsoft.Extensions.Logging` exists but `Microsoft.Extensions.Logging.Console` is a separate package)
- The type exists only in certain TFMs
- InternalsVisibleTo is needed but not configured

**Step-by-step fix:**
1. Search the NuGet package contents or documentation for the exact namespace that now contains the type.
2. Check if the type requires an additional package — many `Microsoft.Extensions.*` namespaces are split across multiple packages.
3. Verify TFM compatibility.
4. If accessing internal types, ensure `[InternalsVisibleTo]` is set on the defining assembly.

**Prevention:**
- Review migration guides when upgrading packages.

---

### CS0012: The type is defined in an assembly that is not referenced

**What it means:** Your code uses a type that comes from a transitive dependency, but the compiler requires a direct reference to that assembly.

**Common root causes:**
- A method returns or accepts a type from a dependency you don't directly reference
- Transitive dependency is not flowing through — `PrivateAssets="all"` on the intermediate reference
- Multi-targeting where the transitive reference exists for one TFM but not another

**Step-by-step fix:**
1. Identify the assembly that defines the type from the error message.
2. Add a direct `<PackageReference>` or `<ProjectReference>` to the assembly containing the type.
3. If this is a transitive reference that should flow, check the intermediate project for `PrivateAssets` or `ExcludeAssets` settings that prevent it.

**Prevention:**
- When exposing types from dependencies in your public API, document the required direct references.

---

### CS8032: An instance of analyzer could not be created

> For comprehensive analyzer and source generator failure diagnosis, see the **`sourcegen-analyzer-failures`** skill. It covers CS8032, CS8785, AD0001, RS-prefixed errors, debugging with `/p:ReportAnalyzer=true`, version mismatches, and TFM incompatibilities.

---

### CS0618: Member is obsolete / CS0619: Member is obsolete and errors

**What it means:** You are using an API member marked with `[Obsolete]`. CS0618 is a warning; CS0619 is an error (when `[Obsolete("...", true)]` is used).

**Common root causes:**
- API was deprecated in a newer version of the library
- The project upgraded a dependency and the previously-used API is now obsolete

**Step-by-step fix:**
1. Read the obsolete message in the warning/error — it typically names the replacement API.
2. If no replacement is named, check the library's migration guide, changelog, or API docs.
3. Replace the obsolete call with the recommended alternative.
4. For CS0618 (warning), if you must temporarily keep the old call, suppress with `#pragma warning disable CS0618` around the call, with a comment explaining when to remove.
5. CS0619 (error) cannot be suppressed — you must replace the call.

**Prevention:**
- Treat warnings as errors (`<TreatWarningsAsErrors>true</TreatWarningsAsErrors>`) to catch deprecations early.

---

### CS0535: Does not implement interface member

**What it means:** A class declares it implements an interface but is missing one or more required members.

**Common root causes:**
- New members were added to the interface in an updated dependency
- The method signature does not exactly match (wrong return type, parameter types, or name)
- Explicit interface implementation is used but the method is missing
- The interface has default implementations but you're targeting a TFM that doesn't support them (pre-C# 8 / pre-netstandard2.1)

**Step-by-step fix:**
1. Check the full interface definition for the version of the dependency you're using.
2. Implement each missing member with the exact signature.
3. If the interface gained new members after an upgrade, check the release notes for guidance on the expected implementation.
4. Use IDE "Implement Interface" refactoring to scaffold missing members.

**Prevention:**
- Review interface changes in release notes before upgrading dependencies.

---

### CS0029: Cannot implicitly convert type

**What it means:** The compiler cannot automatically convert between two types.

**Common root causes:**
- Assigning a value of one type to a variable of an incompatible type
- Nullable reference type (`string?`) assigned to non-nullable (`string`) without null check
- `Task<T>` assigned where `T` is expected (missing `await`)
- Integer types of different widths (e.g., `long` to `int`)
- Custom types that look similar but are from different assemblies or namespaces

**Step-by-step fix:**
1. Check both the source type and target type in the error message.
2. If the types are compatible, add an explicit cast: `(TargetType)value`.
3. If the source is `Task<T>`, add `await` to the expression.
4. If the types are from different assemblies with the same name, fix the reference to use only one.
5. For nullable-to-non-nullable, add a null check or use the `!` operator if you're certain the value is not null.

**Prevention:**
- Enable nullable reference types (`<Nullable>enable</Nullable>`) to catch null issues at compile time.
- Use `await` consistently with async methods.

---

### CS8600–CS8605: Nullable Reference Type Warnings/Errors

**What they mean:**
- **CS8600**: Converting null literal or possible null value to non-nullable type
- **CS8601**: Possible null reference assignment
- **CS8602**: Dereference of a possibly null reference
- **CS8603**: Possible null reference return
- **CS8604**: Possible null reference argument
- **CS8605**: Unboxing a possibly null value

**Common root causes:**
- Nullable reference types are enabled (`<Nullable>enable</Nullable>`) and the code doesn't handle null properly
- A method returns `T?` but the caller treats it as `T`
- API contracts changed — a previously non-nullable return is now nullable
- Third-party library lacks nullable annotations

**Step-by-step fix:**
1. **Preferred:** Add proper null checks before using the value:
   ```csharp
   if (value is not null) { /* use value */ }
   ```
2. Use null-conditional operators: `value?.Method()`.
3. Use the null-forgiving operator `!` only when you are certain the value is not null and the analyzer can't prove it.
4. Annotate your own method signatures correctly with `?` for nullable parameters/returns.
5. To suppress project-wide (not recommended), set `<Nullable>disable</Nullable>` or `<Nullable>warnings</Nullable>`.
6. For third-party APIs without annotations, use `!` at the call site sparingly.

**Prevention:**
- Enable nullable reference types from the start of a project.
- Use `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` to enforce handling.

---

## MSB Errors (MSBuild Engine)

### MSB4019: The imported project was not found

**What it means:** An MSBuild `<Import>` statement references a `.props` or `.targets` file that does not exist on disk.

**Common root causes:**
- Required SDK or workload is not installed (e.g., `Microsoft.NET.Sdk.Web`)
- The `MSBUILD_SDKS_PATH` or SDK resolver path is misconfigured
- A custom `.props`/`.targets` file referenced via a relative path doesn't exist
- The NuGet package that provides the import was not restored
- Corrupt SDK installation
- `global.json` pins an SDK version that is not installed

**Step-by-step fix:**
1. Read the full path in the error message to identify which file is missing.
2. If it's an SDK import (e.g., `Microsoft.NET.Sdk`), run `dotnet --list-sdks` and install the required SDK.
3. If `global.json` exists, check if the pinned SDK version is installed.
4. If the import comes from a NuGet package, run `dotnet restore`.
5. If the import path is custom, verify the file exists at the expected relative path.
6. As a last resort, repair or reinstall the .NET SDK.

**Prevention:**
- Use `global.json` with a `rollForward` policy to avoid pinning to an exact patch version.
- In CI, install the exact SDK version required before building.

---

### MSB3644: The reference assemblies for framework were not found

**What it means:** The targeting pack for the specified TFM is not installed.

**Common root causes:**
- Targeting a .NET Framework version (e.g., `net472`) without the corresponding targeting pack installed
- The .NET Framework Developer Pack is not installed on the build machine
- Multi-targeting includes a TFM for which no targeting pack exists
- Running on Linux/macOS where .NET Framework targeting packs are unavailable without `Microsoft.NETFramework.ReferenceAssemblies` package

**Step-by-step fix:**
1. Install the appropriate .NET Framework Developer Pack from Microsoft.
2. For cross-platform builds targeting .NET Framework, add:
   ```xml
   <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="all" />
   ```
3. If you don't need that TFM, remove it from `<TargetFrameworks>`.

**Prevention:**
- Always include `Microsoft.NETFramework.ReferenceAssemblies` when multi-targeting with .NET Framework TFMs.

---

### MSB3270: There was a mismatch between the processor architecture

**What it means:** A referenced assembly's processor architecture conflicts with the project's target platform.

**Common root causes:**
- Referencing an x86-only assembly from an AnyCPU or x64 project
- Native interop DLLs built for wrong architecture
- Platform target set explicitly in one project but not its dependencies

**Step-by-step fix:**
1. Check `<PlatformTarget>` in both the referencing and referenced projects.
2. Set all projects to `AnyCPU` unless a specific platform is required.
3. If a native dependency requires a specific platform, set all projects in the dependency chain to the same platform, or use `<ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>` to suppress if the mismatch is safe.
4. For native DLLs, provide both x86 and x64 versions and use runtime architecture selection.

**Prevention:**
- Use `AnyCPU` unless you have a specific reason for a platform-specific build.

---

### MSB4181: The task returned false but did not log an error

**What it means:** A custom MSBuild task's `Execute()` method returned `false` (indicating failure) but didn't call `Log.LogError()`.

**Common root causes:**
- Bug in a custom MSBuild task
- The task caught an exception and returned false without logging
- A third-party task has a bug
- Task is swallowing errors internally

**Step-by-step fix:**
1. Identify the task name from the error message.
2. If it's a custom task, fix the `Execute()` method to call `Log.LogError()` before returning `false`.
3. If it's a third-party task, check for updates or file a bug.
4. Build with `dotnet build /bl` and inspect the binlog for more context on what the task was doing.

**Prevention:**
- In custom tasks, always log an error before returning `false`.

---

### MSB3277: Found conflicts between different versions of the same assembly

**What it means:** Multiple dependencies reference different versions of the same assembly, and MSBuild cannot resolve the conflict.

**Common root causes:**
- Transitive dependencies pulling in different versions of a shared library
- Mixing package versions across projects in a solution
- Explicit assembly references (`<Reference>`) conflicting with NuGet-managed versions (note: `<Reference>` is still valid for .NET Framework GAC assemblies like `WindowsBase`)

**Step-by-step fix:**
1. Build with `/bl` and inspect the binlog to see exactly which assemblies conflict.
2. Use `<PackageReference Update="ConflictingPackage" Version="X.Y.Z" />` in `Directory.Build.props` to unify the version across the solution.
3. If using binding redirects (.NET Framework), add or update them in `app.config`.
4. Run `dotnet list package --include-transitive` to see the full dependency graph.
5. Consider using `<CentralPackageManagement>` to enforce consistent versions.

**Prevention:**
- Use Central Package Management (`Directory.Packages.props`) to pin all package versions in one place.

---

### MSB3247: Items had more than one distinct identity within the same ItemGroup

**What it means:** The same item (usually a file) appears more than once in an ItemGroup with conflicting metadata.

**Common root causes:**
- Duplicate `<Compile>`, `<Content>`, or `<None>` entries in the `.csproj`
- Default glob patterns (implicit includes) conflict with explicit includes
- `Directory.Build.props` adds items that the project also adds

**Step-by-step fix:**
1. Check for explicit `<Compile Include="...">` entries that overlap with the default glob (`**/*.cs`).
2. Remove explicit includes that duplicate what the SDK already includes by default.
3. If you need custom metadata on a specific file, use `<Compile Update="file.cs">` instead of `<Compile Include="file.cs">`.
4. Check `Directory.Build.props` and `Directory.Build.targets` for conflicting item additions.

**Prevention:**
- Use `Update` instead of `Include` for files already covered by SDK default globs.
- Avoid mixing SDK-style and non-SDK-style item patterns.

---

### MSB1009: Project file does not exist

**What it means:** MSBuild cannot find the specified project file at the given path.

**Common root causes:**
- Typo in the project file path passed to `dotnet build`
- Case-sensitive file system (Linux) and the casing doesn't match
- The `.csproj` was deleted, moved, or renamed
- Solution file references a project that no longer exists

**Step-by-step fix:**
1. Verify the project file exists at the exact path shown in the error.
2. On Linux, check case sensitivity — `MyProject.csproj` vs `myproject.csproj`.
3. If building a solution, open the `.sln` file and remove or fix stale project references.
4. Check that the working directory is correct.

**Prevention:**
- Use `dotnet sln list` to verify solution contents.
- Use relative paths in solution files.

---

### MSB4236: The SDK could not be found

**What it means:** The MSBuild SDK specified in the project file cannot be resolved.

**Common root causes:**
- Required SDK is not installed (e.g., `Microsoft.NET.Sdk.Worker`, `Microsoft.NET.Sdk.BlazorWebAssembly`)
- `global.json` specifies an SDK version that's not installed
- Custom SDK resolver is misconfigured
- Workload-provided SDKs require the workload to be installed first

**Step-by-step fix:**
1. Check the SDK name in the `<Project Sdk="...">` attribute.
2. Run `dotnet --list-sdks` to see installed SDKs.
3. If `global.json` exists, verify the pinned version is installed or adjust the `rollForward` policy.
4. For workload SDKs (Blazor, MAUI, etc.), run `dotnet workload install <workload>`.
5. Install the required SDK from https://dot.net.

**Prevention:**
- Document required SDK versions and workloads in the repo's README or a setup script.

---

### MSB3106: Assembly name conflict

**What it means:** Two or more projects in the solution produce an output assembly with the same name.

**Common root causes:**
- Copy-pasted project files that retained the same `<AssemblyName>`
- Default assembly name (derived from project file name) collides when projects share the same name in different directories
- Test project and main project have the same assembly name

**Step-by-step fix:**
1. Set a unique `<AssemblyName>` in each conflicting project's `.csproj`.
2. If the projects are in different folders with the same name, rename one of them.
3. Check that `<RootNamespace>` is also unique to avoid confusion.

**Prevention:**
- Use distinct project names across the solution.

---

## NU Errors (NuGet)

> For comprehensive NuGet error diagnosis including feed configuration, authentication, version conflicts, lock files, source mapping, and offline scenarios, see the **`nuget-restore-failures`** skill.
>
> Common NU errors: NU1100, NU1101, NU1108, NU1202, NU1301, NU1603, NU1605, NU1701.

---

## NETSDK Errors (.NET SDK)

> For comprehensive NETSDK error diagnosis including SDK resolution, global.json configuration, workload installation, and roll-forward policies, see the **`sdk-workload-resolution`** skill. It also covers the **`multitarget-tfm-issues`** skill for TFM compatibility problems.
>
> Common NETSDK errors: NETSDK1004, NETSDK1005, NETSDK1013, NETSDK1045, NETSDK1047, NETSDK1064, NETSDK1073, NETSDK1082, NETSDK1141.

---

---

---
name: sourcegen-analyzer-failures
description: "Diagnose and fix source generator and Roslyn analyzer failures in .NET builds. Only activate in MSBuild/.NET build contexts (see shared/domain-check.md for signals). Use when builds fail with CS8785 (source generator errors), AD0001 (analyzer exceptions), RS-prefixed errors, or when source generators produce no output. Covers generator crashes, analyzer exceptions, debugging with /p:ReportAnalyzer=true and binlog analysis, version mismatches, and TFM incompatibilities. DO NOT use for build errors unrelated to analyzers/generators (use common-build-errors instead)."
---

# Source Generator & Analyzer Failure Diagnosis

## Overview

Source generators and Roslyn analyzers run during compilation inside the Csc task. When they fail, the errors can be cryptic. This skill covers diagnosing and fixing these failures.

**Related skills:**
- `common-build-errors` — for general CS/MSB errors not related to generators/analyzers
- `analyzer-performance` — for slow (but working) analyzers, not crashes
- `binlog-failure-analysis` — for deep binlog analysis techniques

---

## Source Generator Failures

### CS8785: Generator 'X' failed to generate source

**What it means**: A source generator threw an unhandled exception during execution.

**Diagnosis steps:**

1. **Check the build output** for the full exception stack trace. MSBuild typically prints the inner exception after the CS8785 message.

2. **Generate a binlog** for deeper analysis:
   ```
   dotnet build /bl:generator-debug.binlog
   ```
   In the binlog, search for CS8785 or the generator name. The Csc task messages will contain the full exception details.

3. **Enable detailed analyzer output:**
   ```
   dotnet build /p:ReportAnalyzer=true
   ```
   This adds timing and error information for each analyzer and generator to the build output.

**Common root causes:**

#### Missing or wrong input files
The generator expects specific files (e.g., `.json`, `.xml`, `AdditionalFiles`) that are missing or have wrong content.

```xml
<!-- Fix: Ensure AdditionalFiles are included -->
<ItemGroup>
  <AdditionalFiles Include="appsettings.json" />
</ItemGroup>
```

#### Target framework incompatibility
The generator package targets `netstandard2.0` but has dependencies that aren't available, or the generator's code uses APIs not in `netstandard2.0`.

```xml
<!-- Check the generator package's target framework -->
<!-- If the generator requires a newer runtime, ensure your build environment has it -->
```

#### Generator package version mismatch with compiler
Source generators depend on specific versions of `Microsoft.CodeAnalysis`. If the compiler version (determined by the SDK) is older than what the generator expects, it crashes.

```xml
<!-- Fix: Update the SDK or pin a compatible generator version -->
<!-- global.json -->
{
  "sdk": {
    "version": "8.0.400",
    "rollForward": "latestFeature"
  }
}

<!-- Or pin an older generator version compatible with your SDK -->
<PackageReference Include="SomeGenerator" Version="1.2.0" />
```

#### Concurrent build access
In parallel builds, generators may fail if they write to shared state or temporary files without locking.

```
<!-- Fix: Ensure UseArtifactsOutput or separate IntermediateOutputPath per TFM -->
<PropertyGroup>
  <UseArtifactsOutput>true</UseArtifactsOutput>
</PropertyGroup>
```

### No Output from Source Generator (Silent Failure)

**Symptom**: The generator runs without errors but produces no files. Types that should be generated are missing, causing `CS0246` or `CS0103` errors.

**Diagnosis:**

1. **Verify the generator is loaded:**
   ```
   dotnet build /p:ReportAnalyzer=true
   ```
   Look for the generator name in the output. If it's not listed, the package isn't being loaded.

2. **Check the package reference:**
   ```xml
   <!-- Generator packages need specific asset configuration -->
   <PackageReference Include="MyGenerator" Version="1.0.0"
                     OutputItemType="Analyzer"
                     ReferenceOutputAssembly="false" />
   ```

3. **Check binlog for generator execution:**
   Load the binlog → search for the Csc task → check `get_task_analyzers` for generator execution details.

4. **Verify the generator's trigger:**
   Most generators use `[Generator]` attribute and `IIncrementalGenerator`. They need specific syntax triggers (attributes, partial classes) in your code. Check the generator's documentation for required trigger patterns.

**Common fixes:**

```xml
<!-- Ensure the generator package is correctly referenced -->
<PackageReference Include="MyGenerator" Version="1.0.0" PrivateAssets="all" />

<!-- If it's a project reference to a generator project -->
<ProjectReference Include="..\MyGenerator\MyGenerator.csproj"
                  OutputItemType="Analyzer"
                  ReferenceOutputAssembly="false" />
```

### Generator Works Locally but Fails in CI

**Common causes:**

1. **SDK version difference** — CI has a different .NET SDK version. Pin via `global.json`:
   ```json
   {
     "sdk": {
       "version": "8.0.400",
       "rollForward": "latestPatch"
     }
   }
   ```

2. **Missing AdditionalFiles** — Files not tracked in source control. Check `.gitignore`.

3. **Path length issues** — Windows CI agents may have long base paths. Use `UseArtifactsOutput` or short output paths.

---

## Analyzer Failures

### AD0001: Analyzer 'X' threw an exception

**What it means**: An analyzer's `Initialize`, `RegisterXxxAction`, or analysis callback threw an unhandled exception.

**Diagnosis:**

1. **Find the full exception** in build output or binlog. The AD0001 message includes the exception type and stack trace.

2. **Identify the analyzer package:**
   ```
   dotnet build /p:ReportAnalyzer=true
   ```

3. **Common causes:**
   - **Version incompatibility**: Analyzer compiled against a newer `Microsoft.CodeAnalysis` than the current compiler provides.
   - **Missing dependencies**: Analyzer has runtime dependencies not present in the build.
   - **Null reference in analyzer code**: The analyzer doesn't handle edge cases in your code (empty files, partial classes, unusual syntax).

**Fixes:**

```xml
<!-- Fix 1: Update the analyzer package -->
<PackageReference Include="SomeAnalyzer" Version="latest-stable" PrivateAssets="all" />

<!-- Fix 2: Suppress the specific analyzer temporarily -->
<PropertyGroup>
  <NoWarn>$(NoWarn);AD0001</NoWarn>
</PropertyGroup>

<!-- Fix 3: Disable a specific analyzer entirely -->
<ItemGroup>
  <Analyzer Remove="@(Analyzer)" Condition="'%(Filename)' == 'ProblematicAnalyzer'" />
</ItemGroup>

<!-- Fix 4: Disable all analyzers during build (for unblocking) -->
<PropertyGroup>
  <RunAnalyzers>false</RunAnalyzers>
</PropertyGroup>
```

### RS Errors (Roslyn SDK Diagnostic Rules)

Common RS errors in analyzer/generator development:

| Error | Meaning | Fix |
|-------|---------|-----|
| `RS1001` | Missing `DiagnosticAnalyzer` export | Add `[DiagnosticAnalyzer(LanguageNames.CSharp)]` |
| `RS1004` | Recommend adding a suppressor | Implement `DiagnosticSuppressor` if applicable |
| `RS1025` | Configure generated code analysis | Set `generated_code = true` in `.editorconfig` |
| `RS1026` | Enable concurrent execution | Call `context.EnableConcurrentExecution()` in `Initialize` |
| `RS2008` | Analyzer release tracking | Add analyzer release tracking files |

### Analyzer Version Compatibility Matrix

| .NET SDK | Roslyn Version | Max Supported Analyzer API |
|----------|---------------|---------------------------|
| 6.0.x | 4.0.x–4.4.x | `Microsoft.CodeAnalysis` 4.x |
| 7.0.x | 4.4.x–4.8.x | `Microsoft.CodeAnalysis` 4.x |
| 8.0.x | 4.8.x–4.12.x | `Microsoft.CodeAnalysis` 4.x |
| 9.0.x | 4.12.x+ | `Microsoft.CodeAnalysis` 4.x |

**Key rule**: Analyzers/generators must target `netstandard2.0` and depend on a `Microsoft.CodeAnalysis` version **less than or equal to** the version shipped with the SDK.

---

## Debugging Techniques

### 1. `/p:ReportAnalyzer=true`

Adds per-analyzer/generator timing and status to build output:

```
dotnet build /p:ReportAnalyzer=true
```

Output shows:
- Each analyzer/generator name
- Execution time
- Any errors or warnings produced

### 2. Binlog Analysis

```
dotnet build /bl:analyzer-debug.binlog
```

In the binlog:
- Find the `Csc` task for the failing project
- Use `get_task_analyzers` to extract analyzer/generator execution data
- Check for exception messages in the task's output messages

### 3. Isolating the Failing Analyzer

```xml
<!-- Temporarily disable all analyzers except the one you're debugging -->
<PropertyGroup>
  <RunAnalyzers>false</RunAnalyzers>
</PropertyGroup>
<ItemGroup>
  <!-- Re-enable only the one you're investigating -->
  <PackageReference Include="OnlyThisAnalyzer" Version="1.0.0" PrivateAssets="all" />
</ItemGroup>
```

### 4. Checking Analyzer Loading

If an analyzer isn't running at all, verify it's being loaded:

```xml
<!-- Check that the analyzer DLL is in the Analyzer item group -->
<!-- In binlog: search for the Analyzer item type in the evaluation -->
```

### 5. Verbose Compiler Logging

For deep Csc-level debugging:
```
dotnet build /p:CscVerbosity=detailed /bl:verbose.binlog
```

---

## Quick-Reference: Error → Fix

| Error | Likely Cause | Quick Fix |
|-------|-------------|-----------|
| `CS8785` | Generator exception | Update generator package; check AdditionalFiles; check SDK version |
| `AD0001` | Analyzer exception | Update analyzer package; suppress with NoWarn temporarily |
| `CS0246` after adding generator | Generator not loaded | Check `OutputItemType="Analyzer"` on PackageReference |
| `CS0103` for generated types | Generator produced no output | Verify trigger syntax (attributes, partial classes) |
| Generator works in VS but not CLI | Different SDK/compiler version | Pin SDK in `global.json` |
| Analyzers slow but not crashing | Not a failure — see `analyzer-performance` skill | Use `/p:ReportAnalyzer=true` for timing |
| `RS1026` | Missing concurrent execution | Add `context.EnableConcurrentExecution()` |

---

## nuget-restore-failures

---
name: nuget-restore-failures
description: "Diagnose and fix NuGet package restore failures in .NET projects. Only activate in MSBuild/.NET build contexts (see shared/domain-check.md for signals). Use when dotnet restore fails, packages can't be resolved, feed authentication fails, or version conflicts occur. Covers nuget.config issues, private feed auth, version conflicts, lock files, source mapping, and offline scenarios. DO NOT use for non-.NET package managers (npm, pip, Maven, etc.)."
---

# NuGet Restore Failures

## Feed Authentication Failures

### Symptoms

- `401 Unauthorized` or `403 Forbidden` during restore
- `Unable to load the service index for source`
- `Response status code does not indicate success: 401`
- Restore works locally but fails in CI

### Azure Artifacts

Install the credential provider:

```shell
# Windows
iex "& { $(irm https://aka.ms/install-artifacts-credprovider.ps1) }"

# Linux/macOS
sh -c "$(curl -fsSL https://aka.ms/install-artifacts-credprovider.sh)"
```

Add the feed with credentials:

```shell
dotnet nuget add source "https://pkgs.dev.azure.com/{org}/{project}/_packaging/{feed}/nuget/v3/index.json" \
  --name "AzureArtifacts" \
  --username "az" \
  --password "<PAT>" \
  --store-password-in-clear-text
```

For CI (Azure Pipelines), use the `NuGetAuthenticate@1` task before restore, or set the `VSS_NUGET_EXTERNAL_FEED_ENDPOINTS` environment variable:

```json
{"endpointCredentials": [{"endpoint":"https://pkgs.dev.azure.com/{org}/_packaging/{feed}/nuget/v3/index.json", "username":"az", "password":"<PAT>"}]}
```

### GitHub Packages

Requires a PAT with `read:packages` scope (and `write:packages` for publishing).

```shell
dotnet nuget add source "https://nuget.pkg.github.com/{OWNER}/index.json" \
  --name "GitHubPackages" \
  --username "{GITHUB_USERNAME}" \
  --password "{PAT}" \
  --store-password-in-clear-text
```

Or configure in `nuget.config`:

```xml
<packageSources>
  <add key="GitHubPackages" value="https://nuget.pkg.github.com/{OWNER}/index.json" />
</packageSources>
<packageSourceCredentials>
  <GitHubPackages>
    <add key="Username" value="{GITHUB_USERNAME}" />
    <add key="ClearTextPassword" value="{PAT}" />
  </GitHubPackages>
</packageSourceCredentials>
```

### Private / Self-Hosted Feeds

Configure credentials in `nuget.config` (user-level at `%APPDATA%\NuGet\NuGet.Config` or `~/.nuget/NuGet/NuGet.Config`):

```xml
<configuration>
  <packageSources>
    <add key="PrivateFeed" value="https://myserver/nuget/v3/index.json" />
  </packageSources>
  <packageSourceCredentials>
    <PrivateFeed>
      <add key="Username" value="user" />
      <add key="ClearTextPassword" value="secret" />
    </PrivateFeed>
  </packageSourceCredentials>
</configuration>
```

> **Important:** The key inside `<packageSourceCredentials>` must exactly match the key in `<packageSources>`. Spaces and special characters in source names must be replaced with `__x0020__` (for space) in the credential section — or just avoid spaces in source names.

### CI/CD Authentication Patterns

**Environment variable approach** — set `NUGET_CREDENTIALPROVIDER_SESSIONTOKENCACHE_ENABLED=true` and provide credentials via `VSS_NUGET_EXTERNAL_FEED_ENDPOINTS`.

**nuget.config transform** — use CI secrets to inject credentials at build time:

```shell
dotnet nuget update source "PrivateFeed" \
  --username "$FEED_USER" \
  --password "$FEED_PAT" \
  --store-password-in-clear-text \
  --configfile ./nuget.config
```

**GitHub Actions example:**

```yaml
- run: dotnet nuget add source "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json" --name github --username ${{ github.actor }} --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
- run: dotnet restore
```

---

## nuget.config Misconfiguration

### Config Hierarchy

NuGet merges config files from multiple levels (closest to project wins):

1. **Project-level** — `nuget.config` next to `.csproj` or `sln`
2. **Directory ancestors** — any `nuget.config` in parent directories up to the drive root
3. **User-level** — `%APPDATA%\NuGet\NuGet.Config` (Windows) or `~/.nuget/NuGet/NuGet.Config` (Linux/macOS)
4. **Machine-level** — `%ProgramFiles(x86)%\NuGet\Config\` (Windows)

Check effective config:

```shell
dotnet nuget list source
```

### The `<clear />` Element

`<clear />` removes all previously-defined sources (from higher-level configs). This is useful for controlling exactly which feeds are used, but can break restore if you forget to re-add `nuget.org`:

```xml
<packageSources>
  <clear />
  <!-- Only these sources will be used -->
  <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
  <add key="PrivateFeed" value="https://myfeed/nuget/v3/index.json" />
</packageSources>
```

**Common mistake:** Adding `<clear />` in a project-level config without re-adding `nuget.org`, causing all public packages to fail resolution.

### Source URL Issues

- **HTTP vs HTTPS** — NuGet 6.3+ blocks HTTP sources by default (`allowInsecureConnections` must be set on the source if HTTP is required)
- **Trailing slashes** — Some servers require them, some break with them. Match the documented URL exactly.
- **v2 vs v3** — Use `/v3/index.json` endpoints. v2 endpoints (`/nuget`) may be deprecated or slower.
- **Typos** — A typo in the feed URL produces `Unable to load the service index`, which looks like an auth error but is a connectivity issue.

### Package Source Ordering

When no source mapping is configured, NuGet queries all configured sources and picks the best (highest version) match. Sources are NOT queried in order of priority — all sources are checked. Use `<packageSourceMapping>` to control which source provides which packages.

---

## Version Conflicts & Resolution

### NU1605: Package Downgrade Detected

Occurs when a transitive dependency pulls a higher version than what's directly referenced:

```
NU1605: Detected package downgrade: Newtonsoft.Json from 13.0.3 to 12.0.1.
```

**Fixes:**

1. Upgrade the direct `<PackageReference>` to the higher version:
   ```xml
   <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
   ```
2. Or suppress the warning (not recommended for production):
   ```xml
   <PropertyGroup>
     <NoWarn>$(NoWarn);NU1605</NoWarn>
   </PropertyGroup>
   ```

### Diamond Dependency Conflicts

Project → PackageA → SharedLib 2.0  
Project → PackageB → SharedLib 1.0

NuGet uses a **nearest-wins** rule: the version closest to the project root wins. If neither is directly referenced, the higher version typically wins. To force a specific version, add an explicit `<PackageReference>`:

```xml
<PackageReference Include="SharedLib" Version="2.0.0" />
```

### Floating Versions

`*` and range syntax (`1.*`, `[1.0, 2.0)`) allow flexible version resolution:

```xml
<PackageReference Include="MyLib" Version="1.*" />    <!-- latest 1.x -->
<PackageReference Include="MyLib" Version="*" />       <!-- latest of any version -->
```

**Risks:** Builds are non-reproducible. A new patch can break things silently. **Pin exact versions** for production projects, or use lock files.

### Central Package Management (CPM)

When `Directory.Packages.props` exists with `<ManagePackageVersions>true</ManagePackageVersions>`, version management changes:

- **`Directory.Packages.props`** defines versions with `<PackageVersion>`:
  ```xml
  <Project>
    <PropertyGroup>
      <ManagePackageVersions>true</ManagePackageVersions>
    </PropertyGroup>
    <ItemGroup>
      <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
    </ItemGroup>
  </Project>
  ```

- **`.csproj` files** reference packages WITHOUT versions:
  ```xml
  <PackageReference Include="Newtonsoft.Json" />
  ```

**Common CPM errors:**

- `NU1008`: Project has a PackageReference with a Version w

[truncated]