---
name: common-build-errors
description: "Knowledge base of common .NET and MSBuild build errors with root causes and solutions. Only activate in MSBuild/.NET build contexts (see shared/domain-check.md for signals). Use when encountering CS, MSB, NU, NETSDK, FS, or BC error codes during dotnet build, dotnet test, msbuild, or dotnet pack. Provides step-by-step fix guidance for each error. DO NOT use for non-.NET build errors (npm, Gradle, CMake, etc.)."
---

# Common .NET and MSBuild Build Errors

## CS Errors (C# Compiler)

### CS0246: The type or namespace name could not be found

**What it means:** The compiler cannot resolve a type or namespace used in code.

**Common root causes:**
- Missing `using` directive for the namespace containing the type
- Missing `<PackageReference>` in the project file for the NuGet package that provides the type
- Missing `<ProjectReference>` to a sibling project that defines the type
- The project targets a TFM where the type does not exist (e.g., using `HttpClient` without a reference on .NET Framework)
- Typo in the type or namespace name
- The package is restored but targets an incompatible framework — the type exists in the package but not for your TFM
- Conditional compilation (`#if`) excluding the code that defines the type

**Step-by-step fix:**
1. Verify spelling of the type name exactly matches the definition.
2. Add the correct `using` directive. Check the type's documentation for the full namespace.
3. If the type comes from a NuGet package, add `<PackageReference Include="PackageName" Version="X.Y.Z" />` to the `.csproj`.
4. If the type is in another project in the solution, add `<ProjectReference Include="..\OtherProject\OtherProject.csproj" />`.
5. Check the project's `<TargetFramework>` — some types only exist in specific TFMs. For example, `System.Text.Json` is inbox in `net6.0+` but requires a PackageReference on `netstandard2.0`.
6. Run `dotnet restore` after adding references.

**Prevention:**
- Use IDE auto-import features to add `using` directives.
- When adding new dependencies, always verify TFM compatibility on nuget.org.

---

### CS0103: The name does not exist in the current context

**What it means:** A variable, method, or type name is used but not declared in the accessible scope.

**Common root causes:**
- Typo in variable or method name
- Variable declared in a different scope (e.g., inside an `if` block, used outside it)
- Missing `using` directive for an extension method's namespace
- Missing `using static` for a static method call
- Code generated by a source generator that hasn't run yet (restore/build order issue)

**Step-by-step fix:**
1. Check spelling of the identifier against its declaration.
2. Verify the variable is declared in a scope visible at the usage site.
3. If calling a static method without the class prefix, add `using static Full.Namespace.ClassName;`.
4. If the name is expected to come from a source generator, ensure the generator package is referenced and `dotnet restore` has been run.
5. Check for `#if` preprocessor directives that might exclude the declaration.

**Prevention:**
- Declare variables at the narrowest scope needed but ensure it covers all usage sites.
- Use consistent naming to avoid typos.

---

### CS1061: Type does not contain a definition for member

**What it means:** You are calling a method or accessing a property that does not exist on the type.

**Common root causes:**
- The member name is misspelled
- The member exists in a different version of the API — package was upgraded or downgraded
- The member is an extension method and the namespace containing it is not imported via `using`
- The variable is a different type than expected (e.g., `object` instead of the concrete type)
- The member was removed or renamed in a newer version of the dependency

**Step-by-step fix:**
1. Verify the exact member name against the API documentation for the version you're using.
2. Check the type of the variable — hover or use `GetType()` at runtime. Cast if needed.
3. For extension methods, add the `using` for the namespace that defines them (e.g., `using System.Linq;` for LINQ methods).
4. Check the package version in your `.csproj` — the member may not exist in the version you have. Compare with API docs or release notes.
5. If the API changed, find the replacement method in the changelog or migration guide.

**Prevention:**
- Pin package versions explicitly.
- Review breaking changes before upgrading major versions.

---

### CS0234: The type or namespace name does not exist in the namespace

**What it means:** The namespace is found but the specific type or sub-namespace within it cannot be resolved.

**Common root causes:**
- The type was moved to a different namespace in a newer version of the library
- A required sub-package is missing (e.g., `Microsoft.Extensions.Logging` exists but `Microsoft.Extensions.Logging.Console` is a separate package)
- The type exists only in certain TFMs
- InternalsVisibleTo is needed but not configured

**Step-by-step fix:**
1. Search the NuGet package contents or documentation for the exact namespace that now contains the type.
2. Check if the type requires an additional package — many `Microsoft.Extensions.*` namespaces are split across multiple packages.
3. Verify TFM compatibility.
4. If accessing internal types, ensure `[InternalsVisibleTo]` is set on the defining assembly.

**Prevention:**
- Review migration guides when upgrading packages.

---

### CS0012: The type is defined in an assembly that is not referenced

**What it means:** Your code uses a type that comes from a transitive dependency, but the compiler requires a direct reference to that assembly.

**Common root causes:**
- A method returns or accepts a type from a dependency you don't directly reference
- Transitive dependency is not flowing through — `PrivateAssets="all"` on the intermediate reference
- Multi-targeting where the transitive reference exists for one TFM but not another

**Step-by-step fix:**
1. Identify the assembly that defines the type from the error message.
2. Add a direct `<PackageReference>` or `<ProjectReference>` to the assembly containing the type.
3. If this is a transitive reference that should flow, check the intermediate project for `PrivateAssets` or `ExcludeAssets` settings that prevent it.

**Prevention:**
- When exposing types from dependencies in your public API, document the required direct references.

---

### CS8032: An instance of analyzer could not be created

> For comprehensive analyzer and source generator failure diagnosis, see the **`sourcegen-analyzer-failures`** skill. It covers CS8032, CS8785, AD0001, RS-prefixed errors, debugging with `/p:ReportAnalyzer=true`, version mismatches, and TFM incompatibilities.

---

### CS0618: Member is obsolete / CS0619: Member is obsolete and errors

**What it means:** You are using an API member marked with `[Obsolete]`. CS0618 is a warning; CS0619 is an error (when `[Obsolete("...", true)]` is used).

**Common root causes:**
- API was deprecated in a newer version of the library
- The project upgraded a dependency and the previously-used API is now obsolete

**Step-by-step fix:**
1. Read the obsolete message in the warning/error — it typically names the replacement API.
2. If no replacement is named, check the library's migration guide, changelog, or API docs.
3. Replace the obsolete call with the recommended alternative.
4. For CS0618 (warning), if you must temporarily keep the old call, suppress with `#pragma warning disable CS0618` around the call, with a comment explaining when to remove.
5. CS0619 (error) cannot be suppressed — you must replace the call.

**Prevention:**
- Treat warnings as errors (`<TreatWarningsAsErrors>true</TreatWarningsAsErrors>`) to catch deprecations early.

---

### CS0535: Does not implement interface member

**What it means:** A class declares it implements an interface but is missing one or more required members.

**Common root causes:**
- New members were added to the interface in an updated dependency
- The method signature does not exactly match (wrong return type, parameter types, or name)
- Explicit interface implementation is used but the method is missing
- The interface has default implementations but you're targeting a TFM that doesn't support them (pre-C# 8 / pre-netstandard2.1)

**Step-by-step fix:**
1. Check the full interface definition for the version of the dependency you're using.
2. Implement each missing member with the exact signature.
3. If the interface gained new members after an upgrade, check the release notes for guidance on the expected implementation.
4. Use IDE "Implement Interface" refactoring to scaffold missing members.

**Prevention:**
- Review interface changes in release notes before upgrading dependencies.

---

### CS0029: Cannot implicitly convert type

**What it means:** The compiler cannot automatically convert between two types.

**Common root causes:**
- Assigning a value of one type to a variable of an incompatible type
- Nullable reference type (`string?`) assigned to non-nullable (`string`) without null check
- `Task<T>` assigned where `T` is expected (missing `await`)
- Integer types of different widths (e.g., `long` to `int`)
- Custom types that look similar but are from different assemblies or namespaces

**Step-by-step fix:**
1. Check both the source type and target type in the error message.
2. If the types are compatible, add an explicit cast: `(TargetType)value`.
3. If the source is `Task<T>`, add `await` to the expression.
4. If the types are from different assemblies with the same name, fix the reference to use only one.
5. For nullable-to-non-nullable, add a null check or use the `!` operator if you're certain the value is not null.

**Prevention:**
- Enable nullable reference types (`<Nullable>enable</Nullable>`) to catch null issues at compile time.
- Use `await` consistently with async methods.

---

### CS8600–CS8605: Nullable Reference Type Warnings/Errors

**What they mean:**
- **CS8600**: Converting null literal or possible null value to non-nullable type
- **CS8601**: Possible null reference assignment
- **CS8602**: Dereference of a possibly null reference
- **CS8603**: Possible null reference return
- **CS8604**: Possible null reference argument
- **CS8605**: Unboxing a possibly null value

**Common root causes:**
- Nullable reference types are enabled (`<Nullable>enable</Nullable>`) and the code doesn't handle null properly
- A method returns `T?` but the caller treats it as `T`
- API contracts changed — a previously non-nullable return is now nullable
- Third-party library lacks nullable annotations

**Step-by-step fix:**
1. **Preferred:** Add proper null checks before using the value:
   ```csharp
   if (value is not null) { /* use value */ }
   ```
2. Use null-conditional operators: `value?.Method()`.
3. Use the null-forgiving operator `!` only when you are certain the value is not null and the analyzer can't prove it.
4. Annotate your own method signatures correctly with `?` for nullable parameters/returns.
5. To suppress project-wide (not recommended), set `<Nullable>disable</Nullable>` or `<Nullable>warnings</Nullable>`.
6. For third-party APIs without annotations, use `!` at the call site sparingly.

**Prevention:**
- Enable nullable reference types from the start of a project.
- Use `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` to enforce handling.

---

## MSB Errors (MSBuild Engine)

### MSB4019: The imported project was not found

**What it means:** An MSBuild `<Import>` statement references a `.props` or `.targets` file that does not exist on disk.

**Common root causes:**
- Required SDK or workload is not installed (e.g., `Microsoft.NET.Sdk.Web`)
- The `MSBUILD_SDKS_PATH` or SDK resolver path is misconfigured
- A custom `.props`/`.targets` file referenced via a relative path doesn't exist
- The NuGet package that provides the import was not restored
- Corrupt SDK installation
- `global.json` pins an SDK version that is not installed

**Step-by-step fix:**
1. Read the full path in the error message to identify which file is missing.
2. If it's an SDK import (e.g., `Microsoft.NET.Sdk`), run `dotnet --list-sdks` and install the required SDK.
3. If `global.json` exists, check if the pinned SDK version is installed.
4. If the import comes from a NuGet package, run `dotnet restore`.
5. If the import path is custom, verify the file exists at the expected relative path.
6. As a last resort, repair or reinstall the .NET SDK.

**Prevention:**
- Use `global.json` with a `rollForward` policy to avoid pinning to an exact patch version.
- In CI, install the exact SDK version required before building.

---

### MSB3644: The reference assemblies for framework were not found

**What it means:** The targeting pack for the specified TFM is not installed.

**Common root causes:**
- Targeting a .NET Framework version (e.g., `net472`) without the corresponding targeting pack installed
- The .NET Framework Developer Pack is not installed on the build machine
- Multi-targeting includes a TFM for which no targeting pack exists
- Running on Linux/macOS where .NET Framework targeting packs are unavailable without `Microsoft.NETFramework.ReferenceAssemblies` package

**Step-by-step fix:**
1. Install the appropriate .NET Framework Developer Pack from Microsoft.
2. For cross-platform builds targeting .NET Framework, add:
   ```xml
   <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="all" />
   ```
3. If you don't need that TFM, remove it from `<TargetFrameworks>`.

**Prevention:**
- Always include `Microsoft.NETFramework.ReferenceAssemblies` when multi-targeting with .NET Framework TFMs.

---

### MSB3270: There was a mismatch between the processor architecture

**What it means:** A referenced assembly's processor architecture conflicts with the project's target platform.

**Common root causes:**
- Referencing an x86-only assembly from an AnyCPU or x64 project
- Native interop DLLs built for wrong architecture
- Platform target set explicitly in one project but not its dependencies

**Step-by-step fix:**
1. Check `<PlatformTarget>` in both the referencing and referenced projects.
2. Set all projects to `AnyCPU` unless a specific platform is required.
3. If a native dependency requires a specific platform, set all projects in the dependency chain to the same platform, or use `<ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>` to suppress if the mismatch is safe.
4. For native DLLs, provide both x86 and x64 versions and use runtime architecture selection.

**Prevention:**
- Use `AnyCPU` unless you have a specific reason for a platform-specific build.

---

### MSB4181: The task returned false but did not log an error

**What it means:** A custom MSBuild task's `Execute()` method returned `false` (indicating failure) but didn't call `Log.LogError()`.

**Common root causes:**
- Bug in a custom MSBuild task
- The task caught an exception and returned false without logging
- A third-party task has a bug
- Task is swallowing errors internally

**Step-by-step fix:**
1. Identify the task name from the error message.
2. If it's a custom task, fix the `Execute()` method to call `Log.LogError()` before returning `false`.
3. If it's a third-party task, check for updates or file a bug.
4. Build with `dotnet build /bl` and inspect the binlog for more context on what the task was doing.

**Prevention:**
- In custom tasks, always log an error before returning `false`.

---

### MSB3277: Found conflicts between different versions of the same assembly

**What it means:** Multiple dependencies reference different versions of the same assembly, and MSBuild cannot resolve the conflict.

**Common root causes:**
- Transitive dependencies pulling in different versions of a shared library
- Mixing package versions across projects in a solution
- Explicit assembly references (`<Reference>`) conflicting with NuGet-managed versions (note: `<Reference>` is still valid for .NET Framework GAC assemblies like `WindowsBase`)

**Step-by-step fix:**
1. Build with `/bl` and inspect the binlog to see exactly which assemblies conflict.
2. Use `<PackageReference Update="ConflictingPackage" Version="X.Y.Z" />` in `Directory.Build.props` to unify the version across the solution.
3. If using binding redirects (.NET Framework), add or update them in `app.config`.
4. Run `dotnet list package --include-transitive` to see the full dependency graph.
5. Consider using `<CentralPackageManagement>` to enforce consistent versions.

**Prevention:**
- Use Central Package Management (`Directory.Packages.props`) to pin all package versions in one place.

---

### MSB3247: Items had more than one distinct identity within the same ItemGroup

**What it means:** The same item (usually a file) appears more than once in an ItemGroup with conflicting metadata.

**Common root causes:**
- Duplicate `<Compile>`, `<Content>`, or `<None>` entries in the `.csproj`
- Default glob patterns (implicit includes) conflict with explicit includes
- `Directory.Build.props` adds items that the project also adds

**Step-by-step fix:**
1. Check for explicit `<Compile Include="...">` entries that overlap with the default glob (`**/*.cs`).
2. Remove explicit includes that duplicate what the SDK already includes by default.
3. If you need custom metadata on a specific file, use `<Compile Update="file.cs">` instead of `<Compile Include="file.cs">`.
4. Check `Directory.Build.props` and `Directory.Build.targets` for conflicting item additions.

**Prevention:**
- Use `Update` instead of `Include` for files already covered by SDK default globs.
- Avoid mixing SDK-style and non-SDK-style item patterns.

---

### MSB1009: Project file does not exist

**What it means:** MSBuild cannot find the specified project file at the given path.

**Common root causes:**
- Typo in the project file path passed to `dotnet build`
- Case-sensitive file system (Linux) and the casing doesn't match
- The `.csproj` was deleted, moved, or renamed
- Solution file references a project that no longer exists

**Step-by-step fix:**
1. Verify the project file exists at the exact path shown in the error.
2. On Linux, check case sensitivity — `MyProject.csproj` vs `myproject.csproj`.
3. If building a solution, open the `.sln` file and remove or fix stale project references.
4. Check that the working directory is correct.

**Prevention:**
- Use `dotnet sln list` to verify solution contents.
- Use relative paths in solution files.

---

### MSB4236: The SDK could not be found

**What it means:** The MSBuild SDK specified in the project file cannot be resolved.

**Common root causes:**
- Required SDK is not installed (e.g., `Microsoft.NET.Sdk.Worker`, `Microsoft.NET.Sdk.BlazorWebAssembly`)
- `global.json` specifies an SDK version that's not installed
- Custom SDK resolver is misconfigured
- Workload-provided SDKs require the workload to be installed first

**Step-by-step fix:**
1. Check the SDK name in the `<Project Sdk="...">` attribute.
2. Run `dotnet --list-sdks` to see installed SDKs.
3. If `global.json` exists, verify the pinned version is installed or adjust the `rollForward` policy.
4. For workload SDKs (Blazor, MAUI, etc.), run `dotnet workload install <workload>`.
5. Install the required SDK from https://dot.net.

**Prevention:**
- Document required SDK versions and workloads in the repo's README or a setup script.

---

### MSB3106: Assembly name conflict

**What it means:** Two or more projects in the solution produce an output assembly with the same name.

**Common root causes:**
- Copy-pasted project files that retained the same `<AssemblyName>`
- Default assembly name (derived from project file name) collides when projects share the same name in different directories
- Test project and main project have the same assembly name

**Step-by-step fix:**
1. Set a unique `<AssemblyName>` in each conflicting project's `.csproj`.
2. If the projects are in different folders with the same name, rename one of them.
3. Check that `<RootNamespace>` is also unique to avoid confusion.

**Prevention:**
- Use distinct project names across the solution.

---

## NU Errors (NuGet)

> For comprehensive NuGet error diagnosis including feed configuration, authentication, version conflicts, lock files, source mapping, and offline scenarios, see the **`nuget-restore-failures`** skill.
>
> Common NU errors: NU1100, NU1101, NU1108, NU1202, NU1301, NU1603, NU1605, NU1701.

---

## NETSDK Errors (.NET SDK)

> For comprehensive NETSDK error diagnosis including SDK resolution, global.json configuration, workload installation, and roll-forward policies, see the **`sdk-workload-resolution`** skill. It also covers the **`multitarget-tfm-issues`** skill for TFM compatibility problems.
>
> Common NETSDK errors: NETSDK1004, NETSDK1005, NETSDK1013, NETSDK1045, NETSDK1047, NETSDK1064, NETSDK1073, NETSDK1082, NETSDK1141.

---
